# Migrated from GitLab CI - test, security, build, deploy
# Docs: https://docs.github.com/en/actions

name: CI

on:
  push:
    branches: [master]
    paths-ignore:
      - '*.yaml'
      - '*.yml'
  pull_request:
    branches: [master]
    paths-ignore:
      - '*.yaml'
      - '*.yml'
  workflow_dispatch:
    inputs:
      do_build:
        description: 'Build and push Docker image'
        required: false
        default: false
        type: boolean
      deploy_staging:
        description: 'Deploy to staging'
        required: false
        default: false
        type: boolean
      deploy_production:
        description: 'Deploy to production (runs after staging)'
        required: false
        default: false
        type: boolean

env:
  PIP_CACHE_DIR: .cache/pip
  DJANGO_SETTINGS_MODULE: webserver_project.settings

jobs:
  # ============== TEST ==============
  test:
    name: Unit tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: django_webserver
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install coverage django-coverage-plugin

      - name: Run migrations
        run: python manage.py migrate

      - name: Run tests with coverage
        run: |
          coverage run --source='main' manage.py test main
          coverage report
          coverage xml -o coverage.xml

      - name: Upload coverage (Cobertura)
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: django_webserver/coverage.xml

  # ============== SECURITY ==============
  security-bandit:
    name: Bandit
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.13'
      - run: pip install bandit
      - run: bandit -r django_webserver/main -f json -o bandit-report.json || echo "Bandit scan complete"
        continue-on-error: true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: bandit-report
          path: bandit-report.json

  security-safety:
    name: Safety
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.13'
      - run: pip install safety
      - run: |
          cd django_webserver
          safety check --json > ../safety-report.json || echo "Safety check complete"
        continue-on-error: true
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: safety-report
          path: safety-report.json

  security-secrets:
    name: Detect secrets
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.13'
      - run: pip install detect-secrets
      - run: detect-secrets scan --baseline .secrets.baseline || echo "Secrets scan complete"
        continue-on-error: true

  # ============== BUILD TO ECR ==============
  build:
    name: Build Docker to ECR
    runs-on: ubuntu-latest
    needs: [test, security-bandit, security-safety, security-secrets]
    if: github.ref == 'refs/heads/master' && github.event_name == 'push' || github.event_name == 'workflow_dispatch' && github.event.inputs.do_build == 'true'
    permissions:
      contents: read
    env:
      AWS_REGION: eu-west-2
      ECR_REPO_NAME: webserver
    outputs:
      image_uri: ${{ steps.ecr-info.outputs.image_uri }}
      account: ${{ steps.ecr-info.outputs.account }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create ECR repository if not exists
        id: ecr-info
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPO_NAME }} 2>/dev/null || \
            aws ecr create-repository --repository-name ${{ env.ECR_REPO_NAME }} --image-scanning-configuration scanOnPush=false
          ACCOUNT=$(aws sts get-caller-identity --query Account --output text)
          echo "account=$ACCOUNT" >> $GITHUB_OUTPUT
          echo "image_uri=$ACCOUNT.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO_NAME }}:latest" >> $GITHUB_OUTPUT

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image to ECR
        env:
          ECR_REGISTRY: ${{ steps.ecr-info.outputs.account }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
        run: |
          docker build -t $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:${{ github.sha }} django_webserver/
          docker tag $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:${{ github.sha }} $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:latest
          docker push $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:${{ github.sha }}
          docker push $ECR_REGISTRY/${{ env.ECR_REPO_NAME }}:latest

      - name: Clean up Docker images
        if: always()
        run: |
          docker image prune -af

  # ============== DEPLOY EC2 + ALB (London eu-west-2, manual) ==============
  deploy-ec2-staging:
    name: Deploy EC2 staging (London)
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/master' && github.event_name == 'push' || github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_staging == 'true'
    environment: staging
    env:
      AWS_REGION: eu-west-2
      STACK_NAME: webserver-ec2-staging
      EC2_KEY_NAME: ${{ secrets.AWS_EC2_KEY_NAME || 'london-ec2' }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get default VPC and subnets
        id: network
        run: |
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query "Vpcs[0].VpcId" --output text)
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          SUBNETS=($(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query "Subnets[*].SubnetId" --output text))
          echo "subnet1=${SUBNETS[0]}" >> $GITHUB_OUTPUT
          echo "subnet2=${SUBNETS[1]}" >> $GITHUB_OUTPUT
          echo "VPC: $VPC_ID, Subnets: ${SUBNETS[0]} ${SUBNETS[1]}"

      - name: Deploy CloudFormation stack (EC2 + ALB)
        run: |
          aws cloudformation deploy \
            --template-file ec2-webserver.yaml \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --parameter-overrides \
              ContainerImageUri=${{ needs.build.outputs.image_uri }} \
              VpcId=${{ steps.network.outputs.vpc_id }} \
              SubnetId=${{ steps.network.outputs.subnet1 }} \
              ALBSubnet1=${{ steps.network.outputs.subnet1 }} \
              ALBSubnet2=${{ steps.network.outputs.subnet2 }} \
              KeyName=${{ env.EC2_KEY_NAME }} \
            --capabilities CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changeset

      - name: Clean up untagged ECR images
        if: always()
        run: |
          aws ecr describe-images --repository-name webserver --region ${{ env.AWS_REGION }} --query 'imageDetails[?imageTags==null].imageDigest' --output text | awk '{for(i=1;i<=NF;i++) print $i}' | while read imageDigest; do
            if [ ! -z "$imageDigest" ]; then
              echo "Deleting untagged image: $imageDigest"
              aws ecr batch-delete-image --repository-name webserver --region ${{ env.AWS_REGION }} --image-ids imageDigest=$imageDigest || echo "Failed to delete $imageDigest"
            fi
          done

      - name: Output ALB DNS and SSH
        run: |
          ALB_DNS=$(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query "Stacks[0].Outputs[?OutputKey=='LoadBalancerDNS'].OutputValue" --output text --region ${{ env.AWS_REGION }})
          INSTANCE_ID=$(aws cloudformation describe-stacks --stack-name ${{ env.STACK_NAME }} --query "Stacks[0].Outputs[?OutputKey=='EC2InstanceId'].OutputValue" --output text --region ${{ env.AWS_REGION }})
          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query "Reservations[0].Instances[0].PublicIpAddress" --output text --region ${{ env.AWS_REGION }})
          echo "App URL: http://$ALB_DNS"
          echo "SSH: ssh -i london-ec2.pem ec2-user@$PUBLIC_IP"

  deploy-production:
    name: Deploy production
    runs-on: ubuntu-latest
    needs: [deploy-ec2-staging]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_production == 'true'
    environment: production
    steps:
      - uses: actions/checkout@v4
      - run: echo "Deploying to production..."
